# Product Requirements Document (PRD) for Simplified AI Prompt Deep-Linking NPM Package

## 1. Introduction

### 1.1 Overview
This PRD outlines the development of a new NPM package, tentatively named `@easy-ai/prompt-linker`, inspired by the existing `@emblemvault/ask-ai` package. The original package is a utility library designed to generate deep-linked prompts for various AI services (e.g., ChatGPT, Claude, Gemini, Grok, Perplexity, Google AI, Kagi, Agent Hustle, and Emblem AI). It allows users to create pre-filled prompts that open directly in these services' web interfaces with a single click, facilitating seamless integration of AI interactions into applications.

The core functionality of `@emblemvault/ask-ai` includes:
- **React Components**: Such as `AskAiGroup` (a container for multiple service buttons) and `AiButton` (for individual services), which render UI elements to trigger AI prompts.
- **Core Utilities**: Functions like `buildPrompt` (to construct service-specific prompt strings) and `buildServiceUrl` (to generate URLs for deep-linking), along with helpers for service configurations.
- **Features**: Support for custom options per service (e.g., model selection for ChatGPT, artifact mode for Claude), modal interactions for user input, TypeScript typings, and browser/CDN compatibility.
- **Purpose**: It bridges user content (e.g., code snippets, text) with AI services without hosting AI models, relying on external endpoints for the actual AI processing.

While `@emblemvault/ask-ai` is functional, it requires users to handle prompt construction, service options, and UI integration with some boilerplate code. Our new package aims to build upon this concept but make it **faster and easier to use** by:
- Simplifying the API with fewer, more intuitive functions and components.
- Reducing configuration overhead through smart defaults and auto-detection.
- Enhancing extensibility for adding new AI services without code changes.
- Improving documentation, examples, and onboarding for quicker adoption.
- Focusing on performance optimizations, such as lazy-loading components and minimized bundle sizes.

This package will be published on NPM under an open-source MIT license, targeting developers building web apps (React-based or vanilla JS) who want to integrate AI prompting without complex setups.

### 1.2 Problem Statement
Developers often need to integrate AI interactions into their apps (e.g., "Explain this code" or "Summarize this text") but face challenges:
- Manually constructing URLs for each AI service is error-prone and time-consuming.
- Supporting multiple services requires maintaining separate logic.
- UI integration (e.g., buttons or modals) adds extra development effort.
- Existing solutions like `@emblemvault/ask-ai` are solid but can feel verbose for simple use cases, requiring explicit prop definitions and imports.

Our package solves this by providing a "plug-and-play" alternative: Install once, configure minimally, and deploy AI links in minutes.

### 1.3 Target Audience
- Front-end developers using React or vanilla JavaScript.
- Full-stack engineers integrating AI into web apps, dashboards, or tools.
- Open-source contributors who may extend the package for new AI services.
- Beginners who want easy AI integration without deep knowledge of service APIs.

### 1.4 Success Metrics
- NPM downloads: Aim for 500+ in the first month post-launch.
- GitHub stars/forks: 100+ stars within 3 months.
- User feedback: 80%+ positive ratings on NPM/GitHub issues.
- Adoption: Integration in at least 5 public repos or projects within 6 months.
- Performance: Bundle size under 10KB gzipped; load time under 100ms for components.

## 2. Goals and Objectives

### 2.1 Primary Goals
- **Ease of Use**: Reduce setup time from 10-15 minutes (in the original package) to under 5 minutes by providing out-of-the-box defaults and a single-entry API.
- **Speed**: Optimize for faster rendering and URL generation, e.g., via memoization and asynchronous handling.
- **Extensibility**: Allow users to add custom AI services via a simple config file or plugin system.
- **Compatibility**: Support React 16+, vanilla JS, and modern browsers; full TypeScript support.
- **Reliability**: Ensure URLs are always valid by including built-in validation and fallback mechanisms.

### 2.2 Secondary Objectives
- Improve accessibility (e.g., ARIA labels on buttons).
- Add analytics hooks for tracking clicks (opt-in).
- Provide comprehensive docs with live demos (e.g., via Storybook or Codesandbox).
- Ensure zero dependencies to keep the package lightweight.

## 3. Features and Requirements

### 3.1 Functional Requirements
The package will be divided into two main exports: UI components (for client-side) and core utilities (for server-side or non-UI use).

#### 3.1.1 Core Utilities (Server-Side/Non-UI)
- **Simplified Prompt Builder**: A single function `createAiPrompt(goal, content, service, options?)` that combines `buildPrompt` and `buildServiceUrl` from the original. 
  - Inputs: `goal` (string, e.g., "Explain this"), `content` (string or object), `service` (enum/string from supported list), `options` (optional object for service-specific params).
  - Output: A ready-to-use URL string.
  - Improvement: Auto-detect content type (e.g., code vs. text) and apply smart formatting; handle encoding automatically.
- **Service Registry**: A configurable object or function to add/remove services dynamically.
  - Default services: Same as original (ChatGPT, Claude, etc.).
  - Example: `addService('newAi', { baseUrl: 'https://newai.com/prompt?q=', params: ['model'] })`.
- **Validation Helper**: `validateUrl(service, url)` to check if generated URLs are reachable (simulated via regex or basic fetch in dev mode).
- **Batch Generation**: `createAiPrompts(goal, content, services[])` to generate URLs for multiple services at once.

#### 3.1.2 UI Components (React-Based)
- **EasyAiButton**: A single button component for one service.
  - Props: Minimal – `goal`, `content`, `service` (required); `label?`, `icon?`, `onClick?` (optional).
  - Behavior: On click, opens the URL in a new tab; optional modal for user input (e.g., append/replace content).
  - Improvement: Built-in icons for each service (via SVG or font icons); customizable styles via CSS-in-JS or props.
- **EasyAiGroup**: Renders a group of buttons for multiple services.
  - Props: `goal`, `content`, `services` (array or 'all' for defaults).
  - Improvement: Auto-layout (e.g., flexbox grid); sortable/orderable via props; theme support (light/dark).
- **Modal Integration**: Built-in modal component triggered by `useModal` prop, using a lightweight library like React Modal (or pure CSS for zero deps).
- **CDN Support**: Browser bundles for non-NPM use, e.g., `<script src="..."></script>` exposing global `EasyAi` object.

#### 3.1.3 Enhancements Over Original
- **Auto-Service Detection**: If no service specified, suggest based on content (e.g., code -> Claude with artifact).
- **Error Handling**: Graceful fallbacks (e.g., alert if service unavailable).
- **Internationalization**: Basic i18n support for button labels.
- **Testing**: 100% coverage with Jest/Vitest for utilities and components.

### 3.2 Non-Functional Requirements
- **Performance**: URL generation < 10ms; component render < 50ms.
- **Security**: No client-side API keys; all operations client-safe (no eval or unsafe eval).
- **Accessibility**: WCAG 2.1 compliant (e.g., keyboard navigation, screen reader support).
- **Bundle Size**: Core < 5KB; Full (with components) < 15KB gzipped.
- **Cross-Browser**: Chrome, Firefox, Safari, Edge (latest versions).
- **Documentation**: README.md with quickstart, API docs (via JSDoc), and examples; separate docs site if needed.

### 3.3 User Stories
- As a developer, I want to install the package via NPM so I can integrate it quickly: `npm install @easy-ai/prompt-linker`.
- As a React user, I want to render a button group with defaults: `<EasyAiGroup goal="Summarize" content={text} />` (auto-uses top 3 services).
- As a server-side dev, I want to generate a URL: `const url = createAiPrompt('Analyze', data, 'grok');`.
- As an advanced user, I want to add a custom service: `addService('myAi', config);`.
- As a beginner, I want examples that copy-paste work without extra setup.

## 4. Technical Specifications

### 4.1 Architecture
- **Monorepo Structure**: Use Lerna or Yarn Workspaces for core and React packages (e.g., `@easy-ai/core` and `@easy-ai/react`).
- **Build Tools**: Rollup for bundling; TypeScript for compilation.
- **Dependencies**: Minimal – React (peer dep for components); no others.
- **Versioning**: Semantic Versioning (start at 1.0.0).

### 4.2 Integration and Deployment
- Publish to NPM via GitHub Actions CI/CD.
- Host docs on GitHub Pages or Vercel.
- Use ESLint/Prettier for code style.

## 5. Roadmap

### 5.1 Phase 1: MVP Development (Weeks 1-2)
- Set up repo and monorepo structure.
- Implement core utilities with default services.
- Add basic tests and TypeScript typings.
- Create README with installation and simple examples.
- Milestone: Publish alpha version (0.1.0) for feedback.

### 5.2 Phase 2: UI Components and Enhancements (Weeks 3-4)
- Build React components (EasyAiButton, EasyAiGroup).
- Add modal and auto-detection features.
- Optimize performance and add i18n basics.
- Expand docs with live demos (Codesandbox).
- Milestone: Beta release (0.5.0); seek community input via GitHub issues.

### 5.3 Phase 3: Extensibility and Polish (Weeks 5-6)
- Implement service registry for custom additions.
- Add analytics hooks and validation.
- Ensure accessibility and cross-browser testing.
- Finalize bundle sizes and optimizations.
- Milestone: Stable release (1.0.0); promote on Reddit, Twitter, and NPM.

### 5.4 Phase 4: Maintenance and Iteration (Ongoing, Months 2+)
- Monitor issues and add new services (e.g., future AI tools).
- Release patches for bug fixes; minors for features.
- Track metrics and iterate based on user feedback.

This PRD provides a comprehensive blueprint for building `@easy-ai/prompt-linker`. It emphasizes simplicity and speed while retaining the core value of the original package. If needed, we can refine based on prototypes or additional requirements.